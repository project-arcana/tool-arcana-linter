#include <fstream>
#include <iostream> // TODO rlog
#include <string>   // TODO cc::string
#include <vector>

#include <clean-core/assert.hh>

#include <task-dispatcher/td.hh>

#include "AstParser.hh"
#include "CodeFile.hh"
#include "WarningLog.hh"
#include "clang_format.hh"
#include "common/cxxopts.hh"
#include "file_util.hh"

int main(int argc, char** argv)
{
    cxxopts::Options option_list("arcana-linter");

    // clang-format off
    option_list.add_options()
        ("h,help", "display this help and exit")
        ("version", "display version information and exit")
        ("v,verbose", "be verbose when parsing")
        ("c,run-clang-format", "run clang format on all encountered cpp files")
        ("clang-format-binary", "the path of the clang-format binary (default: /usr/bin/clang-format)",
         cxxopts::value<std::string>())
        ("file", "the file that is being parsed (last positional argument)",
         cxxopts::value<std::string>());
    option_list.add_options("compilation")
        ("I,include_directory", "add directory to include search path",
         cxxopts::value<std::vector<std::string>>())
        ("D,macro_definition", "define a macro on the command line",
         cxxopts::value<std::vector<std::string>>())
        ("U,macro_undefinition", "undefine a macro on the command line",
         cxxopts::value<std::vector<std::string>>())
        ("f,feature", "enable a custom feature (-fXX flag)",
         cxxopts::value<std::vector<std::string>>())
        ("gnu_extensions", "enable GNU extensions (equivalent to -std=gnu++XX)")
        ("msvc_extensions", "enable MSVC extensions (equivalent to -fms-extensions)")
        ("msvc_compatibility", "enable MSVC compatibility (equivalent to -fms-compatibility)")
        ("fast_preprocessing", "enable fast preprocessing, be careful, this breaks if you e.g. redefine macros in the same file!")
        ("remove_comments_in_macro", "whether or not comments generated by macro are kept, enable if you run into errors");
    // clang-format on
    option_list.parse_positional("file");

    try
    {
        auto options = option_list.parse(argc, argv);
        if (options.count("help"))
            std::cout << option_list.help({"", "compilation"}) << '\n';
        else if (options.count("version"))
        {
            std::cout << "arcana-linter, version 0.0.1" << '\n';
            std::cout << "  cppast version " << CPPAST_VERSION_STRING << '\n';
            std::cout << "  libclang version " << CPPAST_CLANG_VERSION_STRING << '\n';
        }
        else if (!options.count("file") || options["file"].as<std::string>().empty())
        {
            std::cerr << "missing file argument" << std::endl;
            return 1;
        }
        else
        {
            arclint::AstParser parser(options);
            arclint::WarningLog warningLog;

            auto const run_clang_format = options.count("run-clang-format");
            std::string const clang_format_path = (options.count("clang-format-binary") && !options["clang-format-binary"].as<std::string>().empty())
                                                      ? options["clang-format-binary"].as<std::string>()
                                                      : "/usr/bin/clang-format";

            if (run_clang_format && !arclint::is_clang_format_available(clang_format_path.c_str()))
            {
                std::cerr << "Failed to execute clang-format at " << clang_format_path << std::endl;
                std::cerr << "Specify the path using --clang-format-binary <path>" << std::endl;
                return 1;
            }

            auto const root_path = options["file"].as<std::string>();

            std::vector<arclint::CodeFile> code_files;

            auto const iterate_res = arclint::iterate_regular_files(root_path, [&](fs::path const& path) {
                if (arclint::has_cpp_file_extension(path))
                {
                    code_files.emplace_back(path);
                }
                return true;
            });

            td::launch([&] {
                auto s = td::submit_each_ref(
                    [&](arclint::CodeFile& file) {
                        if (run_clang_format)
                        {
                            auto const cf_success = arclint::run_clang_format(file.getFileName().c_str(), clang_format_path.c_str());
                            CC_RUNTIME_ASSERT(cf_success);
                        }

                        file.initialize(parser);
                    },
                    cc::span<arclint::CodeFile>(code_files.data(), code_files.size()));

                td::wait_for(s);
            });

            for (auto const& file : code_files)
            {
                warningLog.registerFile(file);
            }

            if (!iterate_res)
                std::cerr << "Failed to open " << root_path << std::endl;
            else
            {
                warningLog.printSummary();
            }
        }
    }
    catch (cxxopts::OptionException& e)
    {
        std::cerr << "failed to parse options: " << e.what() << std::endl;
        return 1;
    }
}
